<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ include file="_ModuleDefinitions.t4" #>using System;

namespace SunSharp.ObjectWrapper.Modules
{
    public static class ModuleExtensions
    {
<#
var data = DataList.GetModuleSpecificData().OrderBy(m => m.Name);
foreach(var moduleDescription in data) {
#>
        public static <#= moduleDescription.Name #> As<#= moduleDescription.Name#>(this Module module) => new <#= moduleDescription.Name #>(module);
<#
}
#>
    }

<#
foreach(var moduleDescription in data) {
#>
    public struct <#= moduleDescription.Name #>
    {
        public Module Module { get; private set; }

        public <#= moduleDescription.Name #>(Module module){
            Module = module;
        }

<#
    if (moduleDescription.Controllers.Count() != 0){
#>
        #region controllers
<#
        foreach(var controller in moduleDescription.Controllers.OrderBy(c => c.Name)){ 
#>
<#
            if(controller is ValueControllerDescription vcd){
#>

        ///<summary>
        /// Value range: <#= vcd.MinValue #> to <#= vcd.MaxValue #>.
        ///</summary>
        public short Get<#= vcd.Name #>() => (short)Module.GetControllerValue(<#= vcd.Id #>, true);

        ///<summary>
        /// Value range: <#= vcd.MinValue #> to <#= vcd.MaxValue #>.
        ///</summary>
        public void Set<#= vcd.Name #>(float value) => Module.SetControllerValue(<#= vcd.Id #>, value, <#= vcd.MinValue #>, <#= vcd.MaxValue #>);
<#
            } else if(controller is EnumControllerDescription ecd){
#>

        public <#= ecd.EnumTypeName #> Get<#= ecd.Name #>() => (<#= ecd.EnumTypeName #>)Module.GetControllerValue(<#= ecd.Id #>, true);

        public void Set<#= ecd.Name #>(<#= ecd.EnumTypeName #> value) => Module.SetControllerValue(<#= ecd.Id #>, (short)value);
<#
            }
        }
#>

        #endregion controllers
<#
    }
#>
<#
    if (moduleDescription.Curves.Count() != 0){
#>
        #region curves
<#
        foreach(var curve in moduleDescription.Curves.OrderBy(c => c.Name)){ 
#>
        ///<summary>
        /// Read <#= curve.Name #>. <#= curve.Size #> values will be read.
        /// Values are expected to be in range <#= curve.MinValue #> to <#= curve.MaxValue #>. 
        ///</summary>
        public void ReadCurve<#= curve.Name #>(float[] buffer)
        {
            if(buffer.Length < <#= curve.Size #>)
                throw new InvalidArgumentException("Buffer must be at least of size <#= curve.Size #>");

            Module.ReadModuleCurve(<#= curve.Id #>, buffer);
        }

        ///<summary>
        /// Write <#= curve.Name #>. <#= curve.Size #> values will be written.
        /// Values are expected to be in range <#= curve.MinValue #> to <#= curve.MaxValue #>. 
        ///</summary>
        public void WriteCurve<#= curve.Name #>(float[] buffer)
        {
            if(buffer.Length < <#= curve.Size #>)
                throw new InvalidArgumentException("Buffer must be at least of size <#= curve.Size #>");

            Module.WriteModuleCurve(<#= curve.Id #>, buffer);
        }
<#
        }
#>
        #endregion curves
<#
    }
#>

<#
    if (moduleDescription.Enums.Count() != 0){
#>
        #region enums
        
<#
        foreach(var @enum in moduleDescription.Enums.OrderBy(e => e.Name)){
#>
        public enum <#= @enum.Name#> : short
        {
<#
            foreach(var pair in @enum.Values) {
#>
            <#= pair.name #> = <#= pair.value #>,
<#
            }
#>
        }

<#
      }
#>
        #endregion enums
<#
    }
#>
    }
<#
}
#>
}
